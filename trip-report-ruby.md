# Trip Report: MountainWest RubyConf, March 20 & 21, 2014, Salt Lake City, Utah

The fourth and fifth days of MountainWest Hackweek were the [MountainWest RubyConf](http://mtnwestrubyconf.org/2014/), which is the original MountainWest technical conference, now in its @ least seventh year.

## Generate Parsers! Prevent Exploits!

Nick Howard, of Boulder's [Gnip](http://gnip.com/), presented a novel analysis and method for securely validating input in Ruby w/ the hypothesis:

> theory of computation is relevant to web development! (maybe)

Exploits arising from parsing of input are major security issues in web-application development. Nick asked:

> What do exploits have in common? They are unexpected computation. Exploits aren't tricks-- they're computational machines:
1. take input
2. do stuff
3. profit

> The same as usual programs.

Exploits pass input to make use of undocumented behavior. To prevent exploits, we must properly validate inputs, which can leverage the following theories of computation: [decidability](http://en.wikipedia.org/wiki/Decidability_(logic)), for certain types of input, decidability is proven impossible, and [Chomsky Hierarchy](http://en.wikipedia.org/wiki/Chomsky_hierarchy).

Additionally, we should recognize inputs before parsing them and can apply the concepts of [LANGSEC: Language-theoretic Security](http://langsec.org).

Nick then introduced his gem to address this problem: [muskox](https://github.com/baroquebobcat/muskox), a schema-based JSON parser generator that only allows valid strings to be parsed.

## New Ruby 2.1 Awesomeness: Pro Object Allocation Tracing

https://github.com/srawlins/reveal-mwrc14

http://srawlins.github.io/reveal-mwrc14/#/

Sam Rawlins introduced a new feature added with Ruby 2.1 Pro Object Allocation Tracing added to the [`ObjectSpace` module](http://ruby-doc.org/stdlib-2.1.0/libdoc/objspace/rdoc/ObjectSpace.html) via the [`ObjectSpace::trace_object_allocations()`](http://ruby-doc.org/stdlib-2.1.0/libdoc/objspace/rdoc/ObjectSpace.html#method-c-trace_object_allocations) and related functionality.

`ObjectSpace` can be a powerful diagnostic tool for Ruby, as was described in GitHub's blog post [*"Hey Judy, don't make it bad"*](https://github.com/blog/1489-hey-judy-don-t-make-it-bad)

> We tried running `count_objects` on a fresh instance of our main Rails application, as soon as all the libraries and dependencies were loaded:

> ```ruby
GitHub.preload_all
GC.start
count = ObjectSpace.count_objects
puts count[:TOTAL] - count[:FREE]
#=> 605183
```
> Whelp! More than 600k Ruby objects allocated just after boot!

Sam suggested his tooling gems that make use of Ruby's `ObjectSpace` module:

- [AllocationStats](https://github.com/srawlins/allocation_stats)
  > AllocationStats is a rubygem that makes use of Ruby 2.1's new abilities to trace
Ruby object allocations (MRI only). Ruby 2.1's new
`ObjectSpace.trace_object_allocations` methods give only raw information, and
are not immediately useful for anything beyond micro profiling. The data must be
aggregated!

  > AllocationStats collects all of the allocation information generated by
`ObjectSpace.trace_object_allocations`, then provides mechanisms for filtering,
grouping, and sorting the allocation information.

- [Rack AllocationStats](https://github.com/srawlins/rack-allocation_stats)
  > Rack AllocationStats is a Rack Middleware, similar in design to
[rack-perftools_profiler](https://github.com/bhb/rack-perftools_profiler), that
will show information about object allocations that occurr during an HTTP
request

One thing that Sam recommended, from his findings using `ObjectSpace::trace_object_allocations()`, is to use `String#freeze` for code that makes heavy use of strings that aren't modified-- `#freeze` casts the strings as static objects and reduces overhead which would need to be subsequently garbage collected.

## The Other Junk Drawer: My Tests are a Mess

Christopher Sexton delivered a presentation on cleaning up and organizing tests, which often grow out of hand w/ little planning or thought dedicated to organization. Eventually questions of the variety "Should we add a new feature or clean up the test suite?" are asked @ team meetings, and the answer is always "add a new feature".

Nonetheless, your application's tests should be organized so that, like the rest of your application, you can "write code that you understand when you come back to it in six months".

While writing tests w/ organization in mind, Christopher recommends paying attention and knowing when to stop, always testing, and writing acceptance tests and unit tests (for which he recommends Sandi Metz' RailsConf-2013 presentation [The Magic Tricks of Testing](http://www.confreaks.com/videos/2452-railsconf2013-the-magic-tricks-of-testing).

Christopher also provided these other organization tips:

- Tests should follow the [arrange-act-assert](http://c2.com/cgi/wiki?ArrangeActAssert) pattern

- [Mise en Place](http://en.wikipedia.org/wiki/Mise_en_place): Puts your toys away as you go.

- directory structure of tests should mirror application's directory structure

- group logically: puts related things close together

- manage setup ('arrange' step) of tests very carefully

## [Don't.](https://speakerdeck.com/erniemiller/dont)

Rubyist Ernie Miller delivered an engaging presentation where he shared his lessons learned from programming and life:

> We all know that intelligent species learn from mistakes, right

> Thereâ€™s just one problem: Life is too short to make every possible mistake! Also, some mistakes are more costly than others.

Accordingly, shared his list of "Don't"s and his experiences w/ their costs:

- don't overestimate how much time you have
- don't forget that your choices have consequences
- don't fall in love w/ metaprogramming
- don't put your code in 'buckets'
- don't hitch your cart to someone else's horse
- don't think of your app as 'a Rails app'
- don't assume to much about how others will use your objects
- don't use ActiveRecord callbacks, if you can help it (and you can almost always help it)
- don't mistake the illusion of accomplishment for the real thing
- don't accept counter-offers
- don't take a job for the money
- don't assume it's too late
- don't get comfortable
- don't try to be someone you're not
- don't be afraid:
  - don't be afraid to say 'no'
  - don't be afraid to share (*e.g.* Ernie's short-but-sweet blog post [7 Lines Every Gem's Rakefile Should Have](http://erniemiller.org/2014/02/05/7-lines-every-gems-rakefile-should-have/) became his most popular blog post, even though he originally thought it was too obvious to share)
  - don't be afraid to speak
  - don't be afraid to stretch

## The Timeless Way of Building

https://speakerdeck.com/boboroshi/the-timeless-way-of-building-mwrc

John Athayde gave a presentation on the application and lessons of design patterns from the field from which the term originated: Architecture. The books by architect Christopher Alexander provide valuable knowledge that can be applied to software architecture: [The Timeless Way of Building](http://en.wikipedia.org/wiki/The_Timeless_Way_of_Building), [A Pattern Language](http://en.wikipedia.org/wiki/A_Pattern_Language) and [The Oregon Experiment](http://en.wikipedia.org/wiki/The_Oregon_Experiment).


The [Design-Patterns book](http://en.wikipedia.org/wiki/Design_Patterns) was written during time of static-typed languages. We have patterns already implemented in Ruby, *e.g.* iterator pattern: `.each`

Modern software design principles are patterns, *e.g.*

- **DRY**
- **YAGNI**
- **SRP**
- **OCP**
- **LSP**
- **ISP**
- **DIP**
- => **SOLID**

> Patterns all the way down.

Of course, we emulate design patterns, and attempt to avoid or mitigate antipatterns, *e.g.*

- big ball of mud
- walking the tree, / train wrecks
  - better: composition, delegation
- fat models
  - better:
    - modules
    - concerns
    - plugins
    - gems
    - engines
- callbacks
- rails is a series of a very large libraries
- complex finders
  - better: scopes
- generators
- DSL all the things
- good: typographic rendering (readability)
- good: MVC
- untested code
- fat controllers

[Rails Antipatterns](http://railsantipatterns.com/) and [Design Patterns In Ruby](http://designpatternsinruby.com/) were two books that were recommended for avoiding and mitigating antipatterns.

Two parting thoughts on patterns

> Patterns, like all forms of compexity, should be avoided until they are absolutely necessary - http://blog.codinghorror.com/head-first-design-patterns/

Patterns "remind us of what we already know" - Christopher Alexander

## Software Development Lessons from the Apollo Program

Julian Simioni delivered a presentation on the development of the software run by the [guidance computers of the Apollo program](http://en.wikipedia.org/wiki/Apollo_Guidance_Computer) and lessons that are relevant for modern software development. The background information of the presentation was largely derived from the book [Digital Apollo](http://web.mit.edu/digitalapollo/).

Software development for the Apollo program was a challenge, because it was less that 20 years since the term 'software' had even been coined, and the development preceded Unix.

The notable lessons learned, which still apply today, were:

- it is essential to handle failure gracefully
- do unit testing
- write software that is easy to test, in this case it was all functional programming
- do integration testing to prove your code's communication
- astronauts, like all users, don't know what they want:
  - they were distrustful of automation and didn't want automated reentry, but only used manual reentry once

MIT conducted a retrospective of the program's software development and concluded:

- hard problems:
    - making schedules, how to meet them
    - knowing specificationss of other tests
- integration testing was very beneficial

Which largely ring true today.

Julian delivered an engaging and interesting presentation, and the lessons learned and engineering practices are worth paying attention to, as they were applied to the development of software that was critical to the missions and lives of Apollo astronauts. [Digital Apollo](http://web.mit.edu/digitalapollo/) has been added to my to-read list.

